#!/usr/bin/env python
"""
    https://github.com/pieper/dicomsort

    Sorts directories containing dicom files into directories
    with human-readable names for easy organization and manipulation.

    See --help for options

    Steve Pieper pieper@isomics.com

    Not free software - this software is copyright Isomics, Inc. and is confidential.
"""


# {{{ packages and logging utilities

# standard python includes
import sys, os, traceback
import shutil
import time

# special public packages
import dicom
from dicom.filereader import InvalidDicomError

# }}}

class DICOMSorter(object):
    """Implements the logic for sorting dicom files from
    a source directory into a target directory tree
    according to a given set of options.
    """


    def __init__(self):

        self.flagToOptions = {
                '-v': 'verbose',
                '--verbose': 'verbose',
                '-z': 'compressTargets',
                '--compressTargets': 'compressTargets',
                '-d': 'deleteSource',
                '--deleteSource': 'deleteSource',
                '-f': 'forceDeleteSource',
                '--forceDelete': 'forceDeleteSource',
                }

        self.defaultOptions = {
                'sourceDir': None,
                'targetPattern': None,
                'compressTargets': False,
                'deleteSource': False,
                'forceDeleteSource': False,
                'verbose': False,
                }

        self.requiredOptions = [ 'sourceDir', 'targetPattern', ]



    def setOptions(self,options):
        """Set the member variable options based on passed dictionary,
        complaining if require options are missing, and filling in
        optional options with default values if not specified"""
        for option in self.requiredOptions:
            if not options[option]:
                return False
        for option in self.defaultOptions:
            if option not in options:
                options[option] = self.defaultOptions[option]
        self.options = options
        return True


# {{{ main, test, and arg parse

def usage():
    print("dicomsort [options...] sourceDir targetDir/<patterns>")
    print("\n where [options...] can be:")
    print("    [-z,--compressTargets] - create a .zip file in the target directory")
    print("    [-d,--deleteSource] - remove source files/directories after sorting")
    print("    [-f,--forceDelete] - remove source without confirmation")
    print("    [-v,--verbose] - print diagnostics while processing")
    print("    [-t,--test] - run the built in self test (requires internet)")
    print("    [--help] - print this message")
    print("\n <patterns...> is a string defining the output file and directory")
    print("names based on the dicom tags in the file.")
    print("\n Examples:")
    print("\n  dicomsort data sorted/%PatientName/%StudyDate/%SeriesDescription-%InstanceUID.dcm")
    print("\n could create a folder structure like:")
    print("\n  sorted/JohnDoe/2013-40-18/FLAIR-2.dcm")

def selfTest():
    print('run a self test here')
    pass

def parseArgs(sorter,args):
    """Parse the args into an options dictionary
    """
    options = {}
    remainingArgs = []
    while args != []:
        arg = args.pop(0)
        if arg == '--help':
            usage()
            sys.exit()
        if arg == '--test':
            selfTest()
            sys.exit()
        if arg in sorter.flagToOptions.keys():
            options[sorter.flagToOptions[arg]] = True
        elif arg.startswith('-'):
            usage()
            sys.exit(1)
        else:
            remainingArgs.append(arg)
    if len(remainingArgs) != 2:
        usage()
        sys.exit(1)
    options['sourceDir'], options['targetPattern'] = remainingArgs
    if not sorter.setOptions(options):
        usage()
        sys.exit()
    return options

if __name__ == '__main__':
    sorter = DICOMSorter()
    try:
        options = parseArgs(sorter,sys.argv[1:])
        print(options)
        sys.exit()
    except KeyboardInterrupt, e: # Ctrl-C
        raise e
    except SystemExit, e: # sys.exit()
        raise e
    except Exception, e:
        print ('ERROR, UNEXPECTED EXCEPTION')
        print (str(e))
        traceback.print_exc()
        os._exit(1)

# }}}

# vim:set sr et ts=4 sw=4 ft=python fenc=utf-8: // See Vim, :help 'modeline
# vim: foldmethod=marker
